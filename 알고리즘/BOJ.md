# BOJ 알고리즘 풀면서 새로 알게된점, 실수했던점 record...
```
가장 위가 최근 문제풀이!
```
> 문제 잘읽자... 그것만해도 반은간다
---
## BOJ_경사로_14890 (2020.04.21)
- N*N 배열을 위에서 아래로, 왼쪽에서 오른쪽으로 탐색을 해야했다.
- 배열을 돌리는게 아니라 가로 세로로 각각 한 줄씩 읽어 경사로를 만들 수 있는지 체크하면 된다.
- 경사로를 체크할 때 주의할 점은, 낮아지는 경사로를 설치할 때 마지막 지점에 대한 처리가 중요하다. 총 세가지 경우가 있다.
- 다음에 갈 지점의 높이가 같은 경우는 다음 지점에서 시작해야한다.
- 다음에 갈 지점의 높이가 더 높은경우는 불가능하다.
- 다음에 갈 지점의 높이가 더 낮은경우는 끝난지점에서 시작해야한다.
---
## BOJ_복제 로봇_1944 (2020.04.08)
- `Spanning Tree`란 `N`개의 `노드`가 `N-1`개의 `엣지`로 연결되어 있는 트리로, 모든 정점들이 연결되어 있어야 하고, 사이클을 포함하면 안된다.
- `MST(Minimum Spanning Tree, 최소 신장 트리)`란 그래프의 ST 중에서 `간선의 가중치가 최소`가 되는 ST를 말한다.
- MST의 구현 방법으로는 Kruskal과 Prim 두가지가 대표적으로 있다.
- Kruskal : 탐욕적인 방법(greedy method) 을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것
- Kruskal 탐색 순서 : 그래프의 간선을 오름차순으로 정렬 -> 가장 낮은 가중치를 선택함 -> 사이클을 형성한다면 통과 -> N-1개의 간선이 선택되면 끝
- Prim : 시작정점으로부터 신장 트리 집합을 단계적으로 확장
- Prim 탐색 순서 : 시작 정점을 MST에 포함 -> MST에서 가장 가까운 정점을 MST에 포함 -> 계속 반복 -> N-1개의 간선을 가지면 끝
- MST문제는 Union-find를 사용해야한다.
---
## BOJ_로봇 조종하기_2169 (2020.04.07)
- 처음엔 bfs로 시도하려 했는데, 왼쪽으로 갈 수 있다는 경우 때문에 bfs로는 불가능해 보였다.
- 그래서 dfs로 시도해 봤다. 이방법도 아니다. 일반적인 완탐이 안된다.
- 다이나믹 프로그래밍 문제였다.
- 가장 윗줄은 왼쪽에서 오른쪽으로밖에 못간다. 그다음줄 부터는 위-왼, 위-오 방향을 모두 체크해 줘야하므로 2개의 1차원 memo배열을 만든다.
- 두개의 1차원 memo배열에서 큰값을 선택 후 계속 반복하며 한줄 씩 내려간다.
---
## BOJ_Gaaaaaaaaaarden_18809 (2020.04.04)
- 76%에서 시간초과남
- 경우의 수를 살펴보면
- 배양액을 뿌릴 수 있는 칸이 n개이고, 빨간색, 초록색 배양액의 각각 r, g개 라면
- `n C r+g * r+g C r` 이 된다.
- 퍼진 배양액을 for 문을 한번 더 돌면서 q에 넣은게 문제였다. 전체를 돌 필요 없이 퍼진 배양액 중에서 queue에 넣을것만 확인하면 되었다.
- temp queue를 하나 만들어서 배양액 퍼뜨릴때 일단 집어넣고, 1초가 지난 후에 temp queue 돌면서 꽃이 안만들어진것만 넣으니 통과했다.
- 추가로, temp queue에서 확인 후 queue에 넣을 때 완료상태로 만들어주는게 중요하다!