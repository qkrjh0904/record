# 임베디드 OS 개발 프로젝트

## 1장. 임베디드 운영체제

---
## 2장. 개발 환경 구성하기
---
## 3장. 일단 시작하기
---
## 4장. 부팅하기
---
## 5장. UART

#### 5.1. UART 출력하기
- `UART`는 `Universal Asynchronous Receiver/Transmitter`의 약자로 번역하면 범용 비동기화 송수신기이다.
- 가장먼저 UART를 작업하는 이유는 UART를 보통 `콘솔 입출력용`으로 사용하기 때문이다.
- 어떤 데이터 값이든 UART로 주고받을 수 있다. 그래서 UART로 아스키 데이터도 주고받을 수 있는데, 터미널 프로그램을 UART 포트와 연결하면 아스키 코드를 그 코드에 해당하는 문자로 화면에 출력한다. 그러면 터미널 프로그램을 사용해서 명령행 인터페이스 쓰듯 임베디드 시스템을 제어할 수 있다.
- UART를 사용하기 위해서 가장 먼저 해야할 일은 UART 하드웨어의 레지스터를 코드로 만드는 것이다.
- 하드웨어를 사용하는 목적은 다양하고 제조사 입장에서는 그 다양한 요구사항을 할 수 있는 한 최대로 만족해야 하므로 많은 기능을 추가해 넣었기 때문에 우리가 사용하지 않는 레지스터도 많다.
- 초기화하는 하드웨어가 추가될 때마다 해당 하드웨어의 레지스터 구조체와 베이스 주소를 연결해서 추가한다.
- 개별 하드웨어는 각자의 방식으로 동작하더라도 이를 사용하는 `코드는 공용 인터페이스를 통해서 같은 방식으로 사용`할 수 있어야한다. 일종의 `디바이스 드라이버` 같은것이 필요하다.
- 윈도우나 리눅스의 디바이스 드라이버는 매우 복잡한 만큼 범용적으로 쓸 수 있다. PC에서 쓰는 수많은 하드웨어를 제어할 수 있어야하기 때문이다.
- 펌웨어는 그렇게 극단적으로 범용성을 생각할 필요가 없다. 적당한 수준의 범용성만 만족하면 된다. 그래서 `공용 인터페이스 API`만 정의해 놓고 해당 API를 각자 하드웨어가 구현하는 식으로 범용성을 추구한다.
- 각기다른 하드웨어를 공용 API를 통해 접근해 사용한다면 기능 코드를 변경하지 않아도 펌웨어를 다른 하드웨어에 이식할 수 있다. 이런 공용 인터페이스 혹은 API의 설계를 `HAL(Hardware Abstraction Layer)`이라고 한다.
![hal](./img/hal.png)
- UART를 초기화하고 가장 먼저 테스트하는것은 출력이다. 출력이 입력보다 쉽기때문이다.
- 순서는 `하드웨어 꺼놓기->출력 켜기->입력 켜기->다시 하드웨어 켜기`이다. 
- 출력 버퍼가 0이라는 말은 출력 버퍼가 비었다는 뜻이다. 출력버퍼가 비어야 출력 버퍼에 알파벳 하나를 넣어 보낼 수 있다.
- 새로운 디렉터리 추가시 Makefile 수정 순서 
    - VPATH에 새로 만든 디렉터리 추가
    - C_SRCS에도 notdir, wildcard 빌트인 매크로를 사용해 새로 만든 디렉터리 추가
    - INC_DIRS에도 새로 만든 디렉터리 추가
- 

#### 5.2. 안녕 세상!
- 펌웨어에서는 printf()조차 만들어서 써야한다.
- 포인터 파라미터를 읽기 전용으로만 쓸 때 const를 붙이는 것은 좋은 코딩습관이다. 잠재적인 버그를 하나라도 더 미리 발견할 수 있도록 한다.
- while문에서 포인터를 탈출조건으로 줄 때, 포인터 값이 0이되면 탈출한다. C언어에서 NULL이 0이므로 문자열 끝에 포인터가 닿으면 루프를 종료한다.

#### 5.3. UART로 입력 받기
- UART로 출력을 어떻게 했나?
    - 먼저 보내기 버퍼가 비어있는지 확인
    - 비어있으면 데이터 레지스터를 통해 데이터를 보내기 버퍼로 보냄
    - 하드웨어가 알아서 나머지 작업을 처리해주고 하드웨어와 연결된 콘솔에 나타남
- UART 입력은 반대로
    - 받기 버퍼가 채워져 있는지 확인
    - 받기 버퍼에 데이터가 있으면 데이터 레지스터를 통해서 데이터를 하나씩 읽어옴
    - 데이터는 콘솔과 하드웨어를 통해서 전달되어 레지스터에서 펌웨어가 읽어가기만을 기다리고 있음
- 다음 명령으로 오브젝트 파일을 역어셈블하여 어셈블리어 코드를 볼 수 있다.
    ```bash
    $ arm-none-eabi-objdump -d Uart.o
    ```
- 펌웨어란 마른수건도 쥐어 짜듯 최적화를 해야한다.
- 하드웨어 레지스터에 접근하는 시간보다 변수의 값에 접근하는 속도가 훨씬 빠르다. 로컬변수는 보통 스택에 생성되거나 ARM의 범용 레지스터에 할당된다. 둘 다 하드웨어 레지스터보다 수십 혹은 수백배 빠르다.

#### 5.4. printf 만들기
- printf() 함수는 펌웨어에서도 로그나 디버깅 등에 매우 유용하고 자주 사용되는 함수이다.
- printf() 함수는 꽤 복잡하기 때문에 딱 필요한 기능만 최소로 구현하기로 한다.
- printf()라는 이름을 그대로 쓰면, GCC를 포함한 많은 컴파일러가 별다른 옵션을 주지 않는 한 printf() 함수를 단순하게 사용하면 최적화 과정에서 printf() 함수를 puts() 함수로 바꿔버린다.
- 점 세 개(...)는 C 언어 문법으로 가변인자 지정이다. 입력받은 파라미터의 개수를 가변으로 처리하기 때문이다.
    ```c
    unint32_t debug_printf(const char* format, ...);
    ```
- 문자열을 리턴할 때 첫 번째 파라미터를 리턴 포인터로 사용하면 된다.
- ARM은 기본적으로 나누기와 나머지를 지원하는 하드웨어가 없다고 간주한다. 따라서 GCC가 이를 소프트웨어로 구현해 놓은 라이브러리 함수로 자동으로 링킹한다. 만약 나머지와 나누기 하드웨어가 있는 플랫폼 기반의 펌웨어라면 그 함수에서 사용하는 코드를 작성하여 링킹해야한다. 없다면 보통은 표준 라이브러리에서 제공하는 함수로 링킹해야한다.
---
## 6장. 인터럽트
- 컴퓨팅 시스템은 외부의 다른 존재와의 상호작용을 인터럽트로 처리한다. 
- 예를들어 키보드를 치면, 키보드 안의 펌웨어가 인터럽트를 받아 처리하고, 그 결과를 PC에 보낸다.
- 그러면 PC에서도 인터럽트가 발생하고 인터럽트가 발생하고 이 인터럽트를 운영체제가 받아 처리한다. 운영체제는 정해진 신호를 모니터로 보낸다.
- 그럼 모니터에 달려있는 하드웨어는 PC에서 받은 신호로 인터럽트를 발생시켜 모니터의 펌웨어는 이 인터럽트를 적절히 처리해 화면에 글자를 출력한다.
- 사용자와의 상호작용 뿐만 아니라 하드웨어 자체적으로 인터럽트가 발생하는 것도 있다. 타이머 같은 종류의 인터럽트이다. 일정시간이 지나면 계속해서 인터럽트가 발생하도록 설정할 수 있다.
- 하드웨어 인터럽트는 하드웨어에서 펌웨어로 발생한다.
- 인터럽트 처리 순서
    - 우선 인터럽트 컨트롤러를 어떻게 사용하는지 알아야한다.
    - 인터럽트 컨트롤러를 초기화하고 사용하는 코드를 작성한다.
    - 실제 인터럽트를 발생시키는 하드웨어와 인터럽트 컨트롤러를 연결해야한다.
    - 현재 UART만 사용하고 있고, UART는 인터럽트를 발생시키므로 UART와 인터럽트를 연결시킨다.
    - UART는 인터럽트 컨트롤러에 신호를 보내고, 인터럽트 컨트롤러는 ARM 코어로 인터럽트를 보낸다.
    - 펌웨어에서 cpsr의 IRQ 혹은 FIQ 마스크를 끄면 IRQ나 FIQ가 발생했을 때 코어가 자동으로 익셉션 핸들러를 호출한다. 익셉션 핸들러는 펌웨어이다. 그러므로 익셉션 핸들러도 작성해야한다.
    - 익셉션 핸들러에서 적절한 인터럽트 핸들러를 호출하면 인터럽트 처리를 완료한 것이다.
    - 인터럽트를 사용하면 무한 루프 상황에서도 어떤 동작을 하게 할 수 있다.
    - 우리의 목표는 `펌웨어는 무한 루프를 돌고 있지만 키보드 입력에는 반응`하게 만드는 것이다.

#### 6.1. 인터럽트 컨트롤러
- RealViewPB에는 Generic Interrupt Controller라는 이름의 인터럽트 컨트롤러 하드웨어가 달려 있다. 줄여서 GIC이다.
- 가장 먼저 할 일은 GIC의 레지스터 구조체를 만드는 일이다.
- GIC는 레지스터를 크게 두 그룹으로 구분한다. 하나는 `CPU Interface register`이고 다른 하나는 `Distributor register`이다.
- 구조체를 선언했으면 UART때와 마찬가지로 실제 인스턴스를 선언한다.
- 여기서 웹과 굉장히 비슷하다고 느꼈다. 웹의 백엔드 작업에서 DB 설계된 대로 클래스를 만들고 인스턴스를 만드는것처럼, 임베디드에서도 하드웨어의 데이터시트를 보고, 그 하드웨어의 레지스터 구조체를 선언한 후 인스턴스를 만들어 제어하는것이 동일한 매커니즘이다.
- 대부분의 임베디드 시스템은 인터럽트를 한 개 이상 처리하므로 인터럽트를 구분하는 번호가 있다.
- ARM은 모든 인터럽트를 IRQ나 FIQ 핸들러로 처리하므로 IRQ나 FIQ 핸들러에서 개별 인터럽트의 핸들러를 구분해야한다.
- 실제 프로젝트에서 필요한 인터럽트 핸들러 개수는 예측 가능하므로 필요한 숫자에 딱 맞게 인터럽트 배열 크기를 지정하면 된다.
- Priority mask 레지스터는 4~7번 비트만 의미있는 레지스터이고, 나머지는 사용하지 않는다. mask라는 말은 막는다는 말이다. 4~7번 비트를 모두 0으로 설정하면 모든 인터럽트를 마스크 한다는 말이고, 모두 F로 설정하면 0x0~0xE까지 인터럽트를 허용한다는 말이다. 그런데 인터럽트 우선순위의 기본값은 0이므로 실제로 모든 인터럽트를 다 허용한다.
- GIC는 인터럽트 64개를 관리할 수 있다. 그래서 각각 32개씩 레지스터 두 개에 할당한다. IRQ의 시작 번호는 32이다. 그래서 오프셋을 찾으려면 32를 빼면 된다. UART는 IRQ ID가 44번이므로 Enable1 레지스터의 12번 비트에 연결되는 것이다.
- 인라인 어셈블리어의 장점은 스택에 레지스터를 백업 및 복구하는 코드와 리턴 처리하는 코드를 컴파일러가 자동으로 만드는 것이다.
- BIC 명령어를 사용하면 1이 있는 비트에 0을 쓰고, ORR 명령어를 사용하면 반대로 1을 쓴다. 그래서 enable함수에는 BIC명령어를, disable함수에는 ORR을 사용한다.

#### 6.2. UART 입력과 인터럽트 연결



---
## 7장. 타이머
---
## 8장. 태스크
---
## 9장. 스케줄러
---
## 10장. 컨텍스트 스위칭
---
## 11장. 이벤트
---
## 12장. 메시징
---
## 13장. 동기화
---
## 14장. 맺음말
---
## 부록 A

