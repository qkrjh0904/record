작성일 : 2020.04.03 ~ 진행중  
작성자 : 박정호

# 객체지향의 사실과 오해

## 0. 서문

> 객체지향이란 무엇인가에 대한 정확한 답은 없다. 이 질문에대한 자신만의 견해를 가지고 있는가가 중요하다.
>
> 1. 객체지향을 클래스가 아니라 객체를 바라보는 것에서 시작한다.
> 2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 존재로 바라보는것이다.
> 3. 협력에 참여하는 객체들에게 얼마나 적절한 역할과 책임을 부여할 수 있느냐이다.
> 4. 앞서 설명한 개념을 프로그래밍 언어로 흐트러짐 없이 담아낼 수 있어야한다.

## 1. 협력하는 객체들의 공동체

```
객체지향 패러다임의 핵심은 자율적인 객체들의 협력이다.
```

#### 1.1. 협력하는 사람들

- 객체지향의 목표는 실세계를 모방하는것이 아니라 새로운 세계를 창조하는것이다.
- 하지만 객체지향이라는 용어에 담긴 기본 사상을 이해하는데는 실세계의 모방이라는 개념이 매우 효과적이긴 하다.
- 객체지향에서 가장 중요한 개념 세가지는 `역할`, `책임`, `협력`이다.
- 커피주문에서도 손님, 캐시어, 바리스타 사이에 `역할`과 `책임`, `협력`이 존재한다. 물론 다른 모든 일에도 존재한다.
- 일상생활의 대부분의 문제는 혼자만의 힘으로 해결하기 힘들다. 그래서 `요청`이라는것을 한다.
- 손님이 캐시어에게 커피를 주문하는 요청, 캐시어가 바리스타에게 제조를 부탁하는 요청
- `응답`역시 요청의 역방향으로 발생한다.
- `요청`과 `응답`으로 `협력`을 할 수 있게된다.
- `협력`의 성공 여부는 각 개인이 맡은 `역할`을 얼마나 잘 `이행`하는지에 달려있다.
- `역할`은 `책임`을 내포한다. `협력`에 참여하며 특정한 `역할`을 수행하는 사람들은 적합한 `책임`을 수행해야한다.
- 여러사람이 `동일한 역할`을 수행할 수 있다. 누구든 손님, 캐시어, 바리스타의 역할을 맡을 수 있다. 다시말해 `역할`은 대체가능성을 의미한다.
- `책임`을 수행하는 방법은 자율적으로 선택할 수 있다. 같은 요청이라도 바리스타에 따라 다른 커피가 나오는것처럼. 이것이 `다형성(polymorphism)`이다.
- 다시말해 `다형성`이란 `같은 역할`에 대해 `다양한 책임`이 나오는 것이다.
- 한 사람이 `동시에 여러 역할`을 할 수 있다. 회사에선 신입사원 집에서는 아들이 되는것처럼.

#### 1.2. 역할, 책임, 협력

- 사람을 `객체`로, 요청을 `메시지`로, 요청 처리 방법을 `메서드`로 바꾸면 객체지향이라는 문맥으로 옮겨질 수 있다.
- `협력`의 핵심은 특정한 `책임`을 수행하는 `역할`들 간의 연쇄적인 `요청`과 `응답`을 통해 목표를 달성하는것이다.
- Application의 기능은 더 작은 `책임`으로 분할되고 책임은 적절한 `역할`을 수행할 수 있는 `객체`에 의해 수행된다.
- `객체지향의 설계`라는 예술은 `적절한 객체에게 적절한 책임을 할당`하는것에서 시작된다.

#### 1.3. 협력 속에 사는 객체

- 객체지향 어플리케이션의 윤곽을 결정하는것은 역할, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체이다.
- 인간 세계에 사람이 없으면 아무 의미가 없는것처럼, 객체지향에 객체가 없으면 의미가 없다.
- 객체지향 어플리케이션의 아름다움을 결정하는것이 협력이라면, 협력이 얼마나 조화를 이루는지 결정하는것은 객체다. 결국 어플리케이션의 품질을 결정하는것은 객체의 품질이다.
- 1. 객체는 충분히 `협력적`이어야 한다. 전지전능한 객체란 없다. 협력적이란 말은 명령에 따라 행동하는 수동적 존재가 아닌 그저 `요청`에대한 `응답`을 하는것 뿐이다. 응답 안하는 것도, 응답 한다면 어떤 방식으로 응답할지 모두 객체 스스로 결정한다.
- 2. 객체는 `자율적`이어야한다. 스스로의 원칙에 따라 통제하여 일을하기 위해서 자율적이어야 한다.
- 객체도 인간과 동일하다. `공동의 목표(어플리케이션 동작)`를 위해 협력에 참여하지만 스스로의 결정과 판단에 따라 행동하는 자율적인 존재다.
- 바리스타가 커피만드는법을 모른다는것은 말이 안되는것 처럼, 객체가 어떤 `행동(behavior)`을 하기위한 `상태(state)`를 알지 못하는것도 말이 안된다.
- `객체의 자율성`은 객체의 `내부와 외부를 명확히 구분짓는것`으로부터 나온다. 객체의 사적인 부분은 차단하며, 외부에서 접근이 허락된 수단으로만 의사소통 해야한다. 객체는 다른 객체가 `무엇(what)`을 하는지 알 수 있지만 `어떻게(how)` 수행하는지는 알 수 없다.
- 과거의 데이터와 프로세스를 엄격하게 구분하는 개발방법과 객체지향을 구분짓는 가장 핵심적인 차이는 `데이터`와 `프로세스`를 객체에 묶어 놓음으로써 자율성을 보장하는데 있다.
- 객체끼리 의사소통 수단은 단 한가지가 있는데 이를 `메시지`라고 한다.
- 객체가 `메시지`를 처리하는 방법을 `메서드(method)`라고 한다.
- 비유하자면 커피 제조 요청이 메시지, 커피만드는 방법이 메서드이다.
- 외부요청이 무엇인지 표현하는 `메시지`와 이를 처리하는 방법인 `메서드`를 분리하는것은 `객체의 자율성`을 높이는 핵심 메커니즘이다. 이는 `캡슐화(encapsulation)`과 관련돼 있다.

#### 1.4. 객체지향의 본질

객체지향이란?

- 객체지향이란 시스템을 상호작용하는 `자율적인 객체들의 공동체`로 바라보고 이를 객체를 이용해 시스템을 분할하는 방법이다.
- 자율적인 객체란 `상태`와 `행위`를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 `협력`한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 `책임`의 집합이다.
- 객체는 다른 객체와 협력하기 위해 `메시지`를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 `메서드`를 자율적으로 선택한다.

```
중요한 것은 어떤 클래스가 필요한가가 아니라 어떤 객체들이 어떤 메시지를 주고받으며 협력하는가다. 훌륭한 객체지향 설계자가 되기 위해서는 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하는것이 필요하다.

객체지향은 객체를 지향하는것이지 클래스를 지향하는것이 아니다.
```

---

## 2. 이상한 나라의 객체

```
'객체란 무엇인가'라는 본질적인 질문에 대답. 객체가 상태와 행동, 식별자를 가진 존재다.
```

#### 2.1. 객체지향과 인지 능력

- 객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것이다.
- 하지만 객체지향 패러다임의 목적은 현실 세계를 모방하는것이 아닌 현실 세계를 기반으로 새로운 세계를 창조하는 것이다.
- 현실 세계의 객체와 소프트웨어 세계의 객체는 전혀 다른 모습을 보인다.

#### 2.2. 객체, 그리고 이상한 나라

- 앨리스는 상태(키)를 가지며 상태는 변경 가능하다.
- 앨리스의 상태(키)를 변경시키는 것은 앨리스의 행동(키를 줄이고 키우는 행동)이다.
  - 행동의 결과(키를 조절하면서 문 통과 유무)는 상태(행동 결과 현재 키)에 의존적이며 상태를 이용해 서술할 수 있다.
  - 행동의 순서(키를 늘릴것인가 줄일것인가)가 결과(문을 통과하는가 마는가)에 영향을 미친다.
- 앨리스는 어떤 상태(키)에 있더라도 유일하게 식별 가능하다.

#### 2.3. 객체, 그리고 소프트웨어 나라

> 객체란 식별가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

1. 상태

- 과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하기는 어렵다.
- 따라서 인간은 행동의 과정과 결과를 단순하게 기술하기 위해 상태라는 개념을 고안했다.
- 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다.
- 숫자, 문자열, 양, 속도, 시간, 위치, 날짜 등은 객체에 포함 시킬 수 없다. 그저 객체를 표현하는데 사용된다.
- 단순한 값이 아닌 객체를 사용해 다른 객체의 상태를 표현할 수도 있다.
- 음료라는 객체를 사용해 앨리스가 음료를 마시는 상태를 표현하는것 처럼.
- 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 `프로퍼티(property)`라고 한다. 앨리스의 경우 키, 위치, 음료가 앨리스의 프로퍼티가 된다.
- 일반적으로 `프로퍼티`는 변경되지 않고 고정되기 때문에 `정적`이다.
- 반면 `프로퍼티 값(property value)`은 시간이 흐름에 따라 변경되기 때문에 `동적`이다. 키가 변할 수 있고, 위치도 변할 수 있으며, 마시던 음료를 버릴 수도 있다.
- 앨리스와 음료처럼 객체 사이의 의미 있는 연결을 `링크(link)`라고 한다.
- 객체 사이에 `링크`가 존재 해야만 요청(메시지)을 보내고 받을 수 있다.
- 객체를 구성하는 단순한 값은 `속성(attribute)`이라고 한다.
  > 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.

2. 행동

- 객체의 상태는 저절로 변경되지 않는다. 객체의 상태를 변경하는 것은 객체의 자발적인 행동뿐이다.
- 객체의 행동에 의해 객체의 상태가 변경된다는 것은 행동이 `부수효과(side effect)`를 초래한다는 것을 의미한다.
- 객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에게 요청(메시지)을 보내는 것이다.
  > 행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동적하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.
- 현실 세계의 객체와 객체지향 세계의 객체 사이에는 중요한 차이점이 있다. 현실속에서 음료는 스스로 아무것도 할 수 없는 수동적인 존재이다. 현실세계에서 음료의 상태를 변경시키는 주체는 앨리스이지만, 객체지향의 세계에서는 앨리스는 그저 요청(메시지)를 보낼 뿐 상태를 변경시키는 것은 음료 스스로의 몫이다.
- 이 때, 메시지 송신자(앨리스)는 메시지 수신자(음료)의 상태 변경에 대해서는 전혀 알지 못한다. 이것이 `캡슐화`이다.
- 객체가 외부에 노출하는 것은 행동 뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동 뿐이다.
- 객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 객체의 상태를 변경할지 여보는 객체 스스로 결정한다.
- 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다. 이것이 상태를 캡슐화해야하는 이유다.

3. 식별자

- 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다. 이 프로퍼티를 `식별자`라고 한다.
- 숫자, 문자열, 시간, 등과 같이 변하지 않는 양을 `값(value)`라고 하는데, 값은 식별자를 가지지 않는다. 그저 상태를 이용해 두 값이 같은지 판단할 수 있는 `동등성(equality)`을 판단한다.
  > 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
- `참조 객체(reference object)`, 또는 `엔티티(entity)`는 식별자를 지닌 전통적인 의미의 객체를 가리키는 용어다.
- `값 객체(value object)`는 식별자를 가지지 않는 값을 가리키는 용어다.

#### 2.4. 기계로서의 객체

- 객체의 상태를 조회하는 작업을 `쿼리(query)`라고 하고, 객체의 상태를 변경하는 작업을 `명령(command)`이라고 한다.
- 같은 화면을 나타내는 똑같은 기계라도 우리는 두 기계를 구분된 별개의 객체로 인식한다. 이것은 객체의 상태와 무관하게 구분 가능한 식별자를 가진다는 것을 의미한다.

#### 2.5. 행동이 상태를 결정한다.

- 초보자들은 먼저 객체에 필요한 상태가 무엇인지 결정하고 그 상태에 필요한 행동을 결정한다. 이때 몇가지 문제점이 생긴다.
- 첫째, 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태에 초점을 맞추면 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.
- 둘째, 객체를 협력자가 아닌 고립된 섬으로 만든다. 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와의 협력하기 위해서다. 상태를 먼저 고려하면 자연스럽게 협력에 적합하지 못한 객체를 창조하게된다.
- 셋째, 객체의 재사용성이 저하된다. 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다.
- 협력에 참여하는 훌륭한 객체를 만들기 위해서는 상태가 아니라 행동에 초점을 맞추는 것이다. 객체는 다른 객체와 협력하기 위해 존재한다.
- 결과적으로 우리가 애플리케이션 안에서 어떤 행동을 원하느냐가 어떤 객체가 적합한지를 결정한다.
- 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다. 따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야한다.
  > 행동이 상태를 결정한다.

#### 2.6. 은유와 객체

- 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다. 이것이 현실과 객체지향 세계에서의 객체의 차이다.
- 객체지향의 세계는 현실의 추상화가 아니다. 오히려 현실 속의 객체보다 더 많은 특징과 능력을 보유한 객체들로 넘쳐난다.
- 은유는 하나의 의미를 다른 것을 이용해 전달한다는 의미를 가지고 있다. "그남자는 사자같아요"라는 말은 사나운 사자의 특성을 이용해 남자의 성격을 묘사하는 것이다.
- 프로그램 내의 객체는 현실 속의 객체에 대한 은유다. 비록 현실 속의 전화기는 스스로 전화를 걸 수 없지만 현실의 전화기라는 개념을 소프트웨어에 이용하면 그 객체가 전화를 걸 수 있다는 사실을 쉽게 이해할 수 있다.
- 그래서 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있고, 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다. 이러한 이유로 모든 객체지향 지침서에서 현실 세계인 도메인에서 사용되는 이름을 그대로 소프트웨어 객체에 부여하라고 가이드하는것이다.

---

## 3. 타입과 추상화

```
추상화는 단순화를 의미한다. 추상화는 동적인 객체들을 단순화 시켜 정적인 타입으로 갈무리하는 것이다. 타입의 개념을 이해하면 객체를 구현하기 위해 클래스를 사용하는 이유를 이해할 수 있다.
```

---

## 4. 역할, 책임, 협력

```
객체지향 설계의 가장 중요한 재료인 역할, 책임, 협력에 관한 설명.
```

---

## 5. 책임과 메시지

```
훌륭한 메시지가 훌륭한 객체지향 설계의 기반이다. 객체의 자율성과 설계의 유연성은 얼마나 훌륭한 메시지를 선택하느냐에 달려있다.
```

---

## 6. 객체 지도

```
객체지향이 구조와 기능이라는 두 가지 관점을 어떻게 조화시키는지에 관해 설명한다. 구조는 기능에 비해 변화에 더 안정적이다. 따라서 객체지향 패러다임은 객체들의 구조안에 기능을 녹임으로써 변화에 안정적인 소프트웨어를 개발 할 수 있게한다.
```

---

## 7. 함께 모으기

```
1~6장 내용을 코드로 정리한다.
```

---

## 8. 부록A

---

## 9. 추상화 기법

---

## 10. 다 읽고 나서 내가 답할 수 있어야 하는것.

1. 무엇이 객체지향의 사실이냐?

2. 무엇이 객체지향의 오해이냐?
